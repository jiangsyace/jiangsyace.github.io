---
title: MySQL事务隔离级别及实现原理
date: 2020-02-05
categories:
- tech
tags:
- mysql
---

MySQL事务的的隔离级别，以及他们各自对应着什么问题，实现原理是什么？

<!-- more -->

## MySQL事务的隔离级别

并行事务的四大问题：
1. 更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）这是完全没有事务隔离级别造成的，通常数据库的实现是不允许发生这种情况。
2. 脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）
3. 不可重复读：两次读之间有别的事务修改。
4. 幻读：两次读之间有别的事务增删。

对应隔离级别：
1. READ UNCOMMITTED（未提交读）：读取数据不加锁。
  事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读。
2. READ COMMITTED（已提交读）：只读提交的数据，无脏读；
  首先大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象
3. REPEATABLE READ（可重复读）：加行锁，两次读之间不会有修改，无脏读无重复读；
  REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。
  虽然读取同一条数据可以保证一致性，但是却不能保证没有插入新的数据
4. SERIALIZABLE（串行化）：串行化，加表锁，全部串行，无所有问题。
  SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，因此性能会比较低下，在需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。

## 实现原理

READ_UNCOMMITED 的原理：

1. 事务对当前被读取的数据不加锁；
2. 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加`行级共享锁`，直到事务结束才释放。

表现：

1. 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。
2. 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

READ_COMMITED 的原理：

1. 事务对当前被读取的数据加`行级共享锁`（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
2. 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加`行级排他锁`，直到事务结束才释放。

表现：

1. 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。
2. 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

REPEATABLE READ 的原理：

1. 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加`行级共享锁`，直到事务结束才释放；
2. 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加`行级排他锁`，直到事务结束才释放。

表现：

1. 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。
2. 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

SERIALIZABLE 的原理：

1. 事务在读取数据时，必须先对其加`表级共享锁`，直到事务结束才释放；
2. 事务在更新数据时，必须先对其加`表级排他锁`，直到事务结束才释放。

表现：

1. 事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。
2. 事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。

