---
title: 正则表达式语法
date: 2018-3-26 15:17:48
categories:
- tech
---

整理正则表达式的语法和实例。

<!-- more -->

## 语法

### 元字符

| 字符           | 描述                                       |
| ------------ | ---------------------------------------- |
| \            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“`n`”匹配字符“`n`”。“`\n`”匹配一个换行符。串行“`\\`”匹配“`\`”而“`\(`”则匹配“`(`”。 |
| ^            | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“`\n`”或“`\r`”之后的位置。 |
| $            | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“`\n`”或“`\r`”之前的位置。 |
| *            | 匹配前面的子表达式零次或多次。例如，zo*能匹配“`z`”以及“`zoo`”。*等价于{0,}。 |
| +            | 匹配前面的子表达式一次或多次。例如，“`zo+`”能匹配“`zo`”以及“`zoo`”，但不能匹配“`z`”。+等价于{1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，“`do(es)?`”可以匹配“`does`”或“`does`”中的“`do`”。?等价于{0,1}。 |
| {n}          | n是一个非负整数。匹配确定的n次。例如，“`o{2}`”不能匹配“`Bob`”中的“`o`”，但是能匹配“`food`”中的两个o。 |
| {n,}         | n是一个非负整数。至少匹配n次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o*`”。 |
| {n,m}        | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“`o{1,3}`”将匹配“`fooooood`”中的前三个o。“`o{0,1}`”等价于“`o?`”。请注意在逗号和两个数之间不能有空格。 |
| ?            | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“`oooo`”，“`o+?`”将匹配单个“`o`”，而“`o+`”将匹配所有“`o`”。 |
| .            | 匹配除“`\``n`”之外的任何单个字符。要匹配包括“`\``n`”在内的任何字符，请使用像“`(.|\n)`”的模式。 |
| (pattern)    | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“`\(`”或“`\)`”。 |
| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(|)`”来组合一个模式的各个部分是很有用。例如“`industr(?:y|ies)`”就是一个比“`industry|industries`”更简略的表达式。 |
| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95|98|NT|2000)`”能匹配“`Windows2000`”中的“`Windows`”，但不能匹配“`Windows3.1`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95|98|NT|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?<=95|98|NT|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`3.1Windows`”中的“`Windows`”。 |
| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?<!95|98|NT|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。 |
| x\|y         | 匹配x或y。例如，“`z|food`”能匹配“`z`”或“`food`”。“`(z|f)ood`”则匹配“`zood`”或“`food`”。 |
| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。 |
| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`p`”。 |
| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。 |
| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。 |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“`er\b`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。 |
| \B           | 匹配非单词边界。“`er\B`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。 |
| \cx          | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“`c`”字符。 |
| \d           | 匹配一个数字字符。等价于`[0-9]`。                     |
| \D           | 匹配一个非数字字符。等价于`[^0-9]`。                   |
| \f           | 匹配一个换页符。等价于\x0c和\cL。                     |
| \n           | 匹配一个换行符。等价于\x0a和\cJ。                     |
| \r           | 匹配一个回车符。等价于\x0d和\cM。                     |
| \s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| \S           | 匹配任何非空白字符。等价于`[^ \f\n\r\t\v]`。           |
| \t           | 匹配一个制表符。等价于\x09和\cI。                     |
| \v           | 匹配一个垂直制表符。等价于\x0b和\cK。                   |
| \w           | 匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9_]`”。      |
| \W           | 匹配任何非单词字符。等价于“`[^A-Za-z0-9_]`”。          |
| \xn          | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\x41`”匹配“`A`”。“`\x041`”则等价于“`\x04&1`”。正则表达式中可以使用ASCII编码。. |
| \num         | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“`(.)\1`”匹配两个连续的相同字符。 |
| \n           | 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| \nm          | 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 |
| \nml         | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
| \un          | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 |

### 运算符优先级

| 运算符                       | 描述                                       |
| ------------------------- | ---------------------------------------- |
| \                         | 转义符                                      |
| (), (?:), (?=), []        | 圆括号和方括号                                  |
| *, +, ?, {n}, {n,}, {n,m} | 限定符                                      |
| ^, $, \任何元字符、任何字符         | 定位点和序列（即：位置和顺序）                          |
| \|                        | 替换，"或"操作字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |

### 匹配规则

#### 基本模式匹配

一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：

```
^once
```

这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串"once upon a time"匹配，与"There once was a man from NewYork"不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。

```
bucket$
```

这个模式与"Who kept all of this cash in a bucket"匹配，与"buckets"不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：

```
^bucket$
```

只匹配字符串"bucket"。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式

```
once
```

与字符串

```
There once was a man from NewYork
Who kept all of his cash in a bucket.
```

是匹配的。

在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：

```
^\t 
```

类似的，用\n表示"新行"，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\表示，句号.用\.表示，以此类推。

#### 字符簇

在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。

所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：

```
[AaEeIiOoUu]
```

这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：

```
[a-z] //匹配所有的小写字母 
[A-Z] //匹配所有的大写字母 
[a-zA-Z] //匹配所有的字母 
[0-9] //匹配所有的数字 
[0-9\.\-] //匹配所有的数字，句号和减号 
[ \f\r\t\n] //匹配所有的白字符
```

同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如"z2"、"t6"或"g7"，但不是"ab2"、"r2d3" 或"b52"的话，用这个模式：

```
^[a-z][0-9]$
```

尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。

前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示"非"或"排除"的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：

```
^[^0-9][0-9]$
```

这个模式与"&5"、"g7"及"-2"是匹配的，但与"12"、"66"是不匹配的。下面是几个排除特定字符的例子：

```
[^a-z] //除了小写字母以外的所有字符 
[^\\\/\^] //除了(\)(/)(^)之外的所有字符 
[^\"\'] //除了双引号(")和单引号(')之外的所有字符
```

特殊字符"." (点，句号)在正则表达式中用来表示除了"新行"之外的所有字符。所以模式"^.5$"与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。模式"."可以匹配任何字符串，除了空串和只包括一个"新行"的字符串。


#### 匹配次数

到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。

| 字符簇           | 描述                       |
| ------------- | ------------------------ |
| ^[a-zA-Z_]$   | 所有的字母和下划线                |
| ^[a-zA-Z]{3}$ | 所有的3个字母的单词               |
| ^a$           | 字母a                      |
| ^a{4}$        | aaaa                     |
| ^a{2,4}$      | aa,aaa或aaaa              |
| ^a{1,3}$      | a,aa或aaa                 |
| ^a{2,}$       | 包含多于两个a的字符串              |
| ^a{2,}        | 如：aardvark和aaab，但apple不行 |
| a{2,}         | 如：baad和aaa，但Nantucket不行  |
| \t{2}         | 两个制表符                    |
| .{2}          | 所有的两个字符                  |

这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是**前面的字符或字符簇只出现x次** ；一个数字加逗号 {x,} 的意思是**前面的内容出现x或更多的次数** ；两个数字用逗号分隔的数字 {x,y} 表示 **前面的内容至少出现x次，但不超过y次**。我们可以把模式扩展到更多的单词或数字：

```
^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]{0,}$        // 所有的正整数 
^\-{0,1}[0-9]{1,}$      // 所有的整数 
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
```

最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(\.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。

**特殊字符 ? 与 {0,1} 是相等的**，它们都代表着： **0个或1个前面的内容** 或 **前面的内容是可选的** 。

**特殊字符 * 与 {0,} 是相等的**，它们都代表着 **0 个或多个前面的内容** 。

**特殊字符 + 与 {1,} 是相等的**，表示 **1 个或多个前面的内容** 。

所以上面的4个例子可以写成：

```
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^\-?[0-9]+\.?[0-9]*$ // 所有的浮点数
```

##### 贪婪模式、懒惰模式

正则表达式中，表示字符串重复个数元字符，`?,+,*,{}` 默认都会选择贪婪模式，会最大长度匹配字符串，而要切换到懒惰模式，就只是在该元字符后面加多一个”?” 即可切换到非贪婪模式（懒惰模式）

```
字符串："abcabcabc"
表达式(贪婪模式)："a.*a"    匹配字符串："abcabca"
表达式(懒惰模式)："a.*?a"   匹配字符串："abca"
```



#### 分组

分组在正则中用()表示，分组的作用有两个：

+ 将某些规律看成是一组，然后进行组级别的重复，可以得到意想不到的效果。

+ 分组之后，可以通过后向引用简化表达式。

  先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式：

  ​       \d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}

  ​       但仔细观察，我们可以发现一定的规律，可以把.\d{1,3}看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下：

  ​       \d{1,3}(.\d{1,3}){3}

  ​       这样一看，就比较简洁了。

  再来看第二个作用，就拿匹配<title>xxx</title>标签来说，简单的正则可以这样写：

  ​       <title>.*</title>

  ​       可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下：

  ​       <(title)>.*</\1>

  ​       这个例子实际上就是反向引用的实际应用。对于分组而言，整个表达式永远算作第0组，在本例中，第0组是<(title)>.*</\1>，然后从左到右，依次为分组编号，因此，(title)是第1组。

  ​       用\1这种语法，可以引用某组的文本内容，\1当然就是引用第1组的文本内容了，这样一来，就可以简化正则表达式，只写一次title，把它放在组里，然后在后边引用即可。

  ​       以此为启发，我们可不可以简化刚刚的IP地址正则表达式呢？原来的表达式为\d{1,3}(.\d{1,3}){3}，里边的\d{1,3}重复了两次，如果利用后向引用简化，表达式如下：

  ​       (\d{1,3})(.\1){3}

  ​       简单的解释下，把\d{1,3}放在一组里，表示为(\d{1,3})，它是第1组，(.\1)是第2组，在第2组里通过\1语法，后向引用了第1组的文本内容。

  ​       经过实际测试，会发现这样写是错误的，为什么呢？

  ​       小菜一直在强调，**后向引用，引用的仅仅是文本内容，而不是正则表达式！**

  ​       也就是说，组中的内容一旦匹配成功，后向引用，**引用的就是匹配成功后的内容，引用的是结果，而不是表达式。**

  ​       因此，(\d{1,3})(.\1){3}这个表达式实际上匹配的是四个数都相同的IP地址，比如：123.123.123.123。

  ​       至此，读者已经掌握了传说中的后向引用，就这么简单。

#### 断言(零宽断言)

零宽断言的意思是(匹配宽度为零，满足一定的条件/断言) 。用于查找在某些内容(但并不包括这些内容)之前或之后的东西。如果不用断言，以往用过的那些表达式，仅仅能获取到有规律的字符串，而不能获取无规律的字符串。

举个例子，比如html源码中有<title>xxx</title>标签，用以前的知识，我们只能确定源码中的<title>和</title>是固定不变的。因此，如果想获取页面标题(xxx)，充其量只能写一个类似于这样的表达式：<title>.*</title>，而这样写匹配出来的是完整的<title>xxx</title>标签，并不是单纯的页面标题xxx。

想解决以上问题，就要用到断言知识。

无论是先行还是后发，都是相对于xxx而言的，也就是相对于目标字符串而言。

假如目标字符串后边有条件，可以理解为目标字符串在前，就用先行断言，放在目标字符串之后。

假如目标字符串前边有条件，可以理解为目标字符串在后，就用后发断言，放在目标字符串之前。

假如指定满足某个条件，就是正。

假如指定不满足某个条件，就是负。

断言只是条件，帮你找到真正需要的字符串，本身并不会匹配！

| 语法       | 描述                                       |
| -------- | ---------------------------------------- |
| `(?=X)`  | 零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。 |
| `(?!X)`  | 零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配 。 |
| `(?<=X)` | 零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?<=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。 |
| `(?<!X)` | 零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?<!19)99 与不跟在 19 后面的 99 的实例匹配 |


##### 正先行断言

什么是正先行断言，就是在字符串相应位置之前进行查找匹配，使用   (?=exp) 匹配exp前面的位置。 
实例

```
字符串："abcgwcab"
表达式：'bc(?=gw)'
匹配字符串：'bc'
```

解析：首先查找字符串”abcgwcab”中gw位置，断言为真，然后在匹配bc。如果将正则表达式写成`$parent='/bc(?=gw)ca/';` 将会匹配不成功。

##### 反先行断言

什么是反先行断言，使用 (?!exp) 匹配后面跟的不是exp。 
实例：

```
字符串："abcgwcab"
表达式：'bc(?!ww)gw'
匹配字符串：'bcgw'
```

解析：首先判断字符串是否包含bc，然后判断其后面不是ww,最后匹配gw。可以看出反向断言之前后之后，能够在添加其他匹配条件。

##### 正后发断言

什么是正后发断言，就是在字符串相应位置之后进行查找匹配， (?<=exp) 匹配exp后面的位置 
实例：

```
字符串："abcgwcab"
表达式：'(?<=gw)ca'
匹配字符串：'ca'
```

解析：第一步，查找字符”abcgwcab”中是否包含有gw，返回结果为true，然后进行第二步，查找gw后面是否有ca。

##### 反后发断言

什么是反后发断言，使用(?

```
字符串："abcgwcab"
表达式：'(?<!bc)gw'
匹配字符串：''
```

解析：首先在字符串中匹配gw，然后判断其前面是不是bc，发现其前面是bc，故返回false。

##### 实例

例1：`\d+(?=abc)` 
判断一个字符串中是否包含’abc’，且其前面是否包含一个或多个数字 
例2：`(?<=\d\d)\w` 
判断字符串中是否存在连续两个数字，且其后面包含一个字母 
例3：`\d{3} (?!55)` 
判断字符串中是否包含连续三个数字，且三个数字后面不是55 
例4：`(?<!ac)\w\d` 
判断一个字符串是否包含一个字母加数字的组合，且其前面不是ac

##### 总结

先行断言与后发断言区别？ 
先行断言是判断断言之前的正则表达式，断言在其他正则表达式之后。后发断言是判断断言之前的正则表达式，断言在其他正则表达式之前。这里的先与后，是其他匹配相对应断言在正则表达式中的顺序。



## 实例

### 常用实例

| 描述              | 表达式                                      |
| --------------- | ---------------------------------------- |
| 用户名             | `/^[a-z0-9_-]{3,16}$/`                   |
| 密码              | `/^[a-z0-9_-]{6,18}$/`                   |
| 十六进制值           | `/^#?([a-f0-9]{6}\|[a-f0-9]{3})$/`       |
| 电子邮箱            | `/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})` |
| URL             | `/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/` |
| IP 地址           | `/((2[0-4]\d\|25[0-5]\|[01]?\d\d?)\.){3}(2[0-4]\d\|25[0-5]\|[01]?\d\d?)//^(?:(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)$/` |
| HTML 标签         | `/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>\|\s+\/>)$/` |
| 删除代码\\注释        | `(?<!http:\|\S)//.*$`                    |
| Unicode编码中的汉字范围 | `/^[\u2E80-\u9FFF]+$/`                   |

### 复杂实例

1. 提取所有a标签中的链接： `(?<=href=")(.*?)(?=\")`

```
<a href="https://www.baidu.com/">百度</a>
<a href="https://www.google.com/">谷歌</a>
```

## 在线测试

[http://tool.oschina.net/regex/](http://tool.oschina.net/regex/)

[https://c.runoob.com/front-end/854](https://c.runoob.com/front-end/854)

[https://www.sojson.com/regex/](https://www.sojson.com/regex/)

[https://tool.lu/regex/](https://tool.lu/regex/)

## 参考资料

[正则表达式手册](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

[正则表达式 - 教程](http://www.runoob.com/regexp/regexp-tutorial.html)

## 