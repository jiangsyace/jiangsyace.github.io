---
title: 使用消息队列实现分布式事务
date: 2020-04-08
categories:
- tech
tags:
- java
---

分布式事务的实现方式有多种，比较常用的可大致分为两类，一类是使用TCC补偿性事务实现的强一致性事务，另一种是使用消息队列实现的最终一致性的事务，在一些高并发的场景下，可能会倾向于使用事务消息来实现。

<!-- more -->

## 技术分析

使用消息队列来实现分布式事务，通常是把分布式的事务拆分成本地事务来执行，然后通过消息队列来进行多个本地事务之间的协调，实现过程需要解决以下几个问题：
+ 可靠保存凭证（消息），本地事务一旦提交，就必须保证消息也一定提交到消息队列中，要充分考虑事务回滚而消息已经提交到队列中，又或者事务已提交而程序中断没有发送消息到队列中的情况。
+ 多个本地事务其中一个产生回滚，要保证通知其他事务一起回滚，达到一致性。
+ 事务消息被多次产生或多次消费的情况，除了消息队列作相应配置以外，程序也需要通过状态机等方式保证幂等性。

**保证最终一致性的模式**
+ 可查询模式，任何一个服务操作都提供一个可查询接口，用来向外部输出操作执行的状态，下游Consumer可以通过接口得知服务操作执行的状态，然后根据不同的状态做不同的处理操作（执行或者取消）， 该模式对业务接口有一定侵入性。
+ 补偿模式， 有了查询模式，我们能够知道操作的具体状态，如果处于不正常状态，我们可以修正操作中出现的问题，或许是重新执行，或许取消已经完成的操作，通过修复使得整个分布式系统达到最终一致。
+ 最大努力通知模式， 在调用支付宝交易接口或微信支付接口时，一般会在回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。同时，只有当回调页面中输出了success字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。

**业务接口的幂等性**
消息的重复发送会导致业务接口出现重复调用的问题，主要原因就是消息没有及时收到ACK确认导致的，那如何实现幂等性设计呢？

在实际的业务场景中，业务接口的幂等性设计，常结合查询操作一起使用，

比如根据唯一标识查询消息是否被处理过，或者根据消费日志表，来维护消息消费的记录。

### 实现方案一：消息表

实现思路：
+ 使用消息表来记录事务的执行状态，业务表与消息表在同一个事务中提交，保证了本地事务一旦提交就一定有个状态表示，一旦程序中断造成本地事务没有同步到消息队列，那么系统的定时任务会自动扫描消息表中未完成的事务发送到消息队列中。
+ 各个分布式模块通过监听特定队列的消息，实现本地事务回滚。
+ 在保存消息表时设置订单号为唯一索引，并加入版本号，每次修改进行校验，避免多次处理，保证了幂等性。也可使用redis存储处理过的消息来实现判重。

实现过程：
+ 首先执行本地事务，本地事务包括保存业务数据和消息数据，消息表中的状态标识为待提交。
+ 保存数据后发送消息到消息队列，发送成功后，修改消息表中的状态为处理中，如果发送失败则重试，一定次数后仍然不成功则回滚当前本地事务。
+ 其他分布式模块监听到有处理中的消息后，执行本地事务同时也保存消息表，状态为已处理，保存数据后发送已处理的消息到消息队列。
+ 其他分布式模块监听到有已处理的消息后，更新本地事务状态为已处理。

优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。
缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。而且严重依赖数据库的消息表来管理事务，高并发场景下会有性能瓶颈。

### 实现方案二：RocketMQ 事务消息

上面的方案中由于消息数据与业务数据耦合在一起，从架构上看不够优雅，而且容易诱发其他问题，所以我们也可以采用RocketMQ提供的事务消息功能。简单来说，分成3个步骤：
1. 发送Prepared消息 
2. update DB 
3. 根据update DB结果成功或失败，Confirm或者取消Prepared消息。
同时，RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去，还是取消此条消息。

实现过程：

+ A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
+ 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
+ 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
+ mq 会自动定时轮询所有 prepared 消息回调你的接口，去询问这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也可以回滚。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。

优点：消息数据独立存储，降低业务系统与消息系统间的耦合；
缺点：一次消息发送需要两次请求；业务处理服务需要实现消息状态回查接口。而且主流MQ不支持，RocketMQ事务消息部分代码也未开源。


具体代码实现如下：

也就是定义了一个checkListener，RocketMQ会回调此Listener，从而实现上面所说的方案。
```
// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务
TransactionCheckListener transactionCheckListener = new TransactionCheckListenerImpl();
// 构造事务消息的生产者
TransactionMQProducer producer = new TransactionMQProducer("groupName");
// 设置事务决断处理类
producer.setTransactionCheckListener(transactionCheckListener);
// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑
TransactionExecuterImpl tranExecuter = new TransactionExecuterImpl();
producer.start();
// 构造MSG，省略构造参数
Message msg = new Message(......);
// 发送消息
SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, null);
producer.shutdown();
```

然后执行本地事务，具体代码如下
```
public TransactionSendResult sendMessageInTransaction(.....)  {
    // 逻辑代码，非实际代码
    // 1.发送消息
    sendResult = this.send(msg);
    // sendResult.getSendStatus() == SEND_OK
    // 2.如果消息发送成功，处理与消息关联的本地事务单元
    LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);
    // 3.结束事务
    this.endTransaction(sendResult, localTransactionState, localException);
}
```
上面所说的消息中间件上注册的listener，超时以后会回调producer的接口以确定事务执行情况

总结：对比方案2和方案1，RocketMQ最大的改变，其实就是把“扫描消息表”这个事情，不让业务方做，而是消息中间件帮着做了。

至于消息表，其实还是没有省掉。因为消息中间件要询问发送方，事物是否执行成功，还是需要一个“变相的本地消息表”，记录事物执行状态。

**人工介入**

无论方案1，还是方案2，发送端把消息成功放入了队列，但消费端消费失败怎么办？

消费失败了，重试，还一直失败怎么办？是不是要自动回滚整个流程？

答案是人工介入。从工程实践角度讲，这种整个流程自动回滚的代价是非常巨大的，不但实现复杂，还会引入新的问题。比如自动回滚失败，又怎么处理？

对应这种极低概率的case，采取人工处理，会比实现一个高复杂的自动化回滚系统，更加可靠，也更加简单。

## 总结

通过消息队列来实现事务，本质上都是二阶段提交来实现的，事务消息都保存在单独的主题上，而RocketMQ提供的“半消息”功能，可以避免使用本地数据库来管理事务，提升性能。















