---
title: TCP握手原理
date: 2020-01-13
categories:
- tech
tags:
- tcp
---

TCP是面向连接的传输协议，在传输数据前要建立连接，分别是三次握手建立连接，四次握手关闭连接。

<!-- more -->

## 建立连接（三次握手）

### 通信过程

![](/assets/upload/2020-01-13/2095550-d49db915d308c518.png)


+ 第一次握手：客户端向服务器发送一个SYN同步数据包请求建立连接SYN（SEQ = x），客户端进入SYN_SENT状态。
+ 第二次握手：服务器收到这个同步请求数据包后，会对客户端进行一个同步确认，发送SYN（SEQ = y）ACK（ACK = x + 1）报文，确认号是接受到的序列号+1，服务器进入SYN_RECV状态。
+ 第三次握手：客户端收到这个同步确认数据包后，再对服务器进行一个确认，发送一个ACK（ACK = Y + 1）报文，确认号是接受到的序列号+1，进入连接状态。
注意：因为一个SYN将占用一个序号，所以要加1。

### 思考
+ 为什么需要三次握手呢？
  + 为了方式由于网络问题导致数据包重传，客户端发送了多个建立连接请求而服务端也建立了多个响应在等待，造成资源浪费。
  + 看过一本书，上面把三次握手的过程看成是客户端和服务端**确认对方通信能力**的一个过程。
  + 首先，客户端向服务端发一封信（第一次握手），当服务端收到后就能知道，客户端的发信能力是没问题的，而服务端能收到也说明自己收信能力也是没问题的。
  + 然后服务端也向客户端回一封信（第二次握手），如果客户端收到了就表明，客户端发的信服务端收到了，而且现在还收到了来自服务端的回信，所以自己的发信和收信能力都没问题，服务端的发信和收信能力也没问题。
  + 最后还剩下的，就是服务端自己还不知道自己的发信能力是否有问题，这时候客户端再向服务端回一封信（第三次握手），服务端收到后，双方都确认了对方和自己的通信能力都没问题，进入了连接状态。

+ TCP的快速重传和拥塞机制
  + TCP遇到超时丢包等问题会用到重传机制。其基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。
  + 拥塞机制是TCP为了避免由于发送了过量的数据而导致阻塞，慢启动是TCP的一个拥塞控制机制，慢启动算法的基本思想是当TCP开始在一个网络中传输数据或发现数据丢失并开始重发时，首先慢慢的对网路实际容量进行试探，避免由于发送了过量的数据而导致阻塞。  


## 关闭连接（四次握手）

### 通信过程

![](/assets/upload/2020-01-13/1058153-20180725001243103-1566648394.png)
+ 第一次握手：客户端发送一个关闭连接的FIN包（FIN = 1,序号seq = u），用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。
+ 第二次握手：服务端收到关闭连接的FIN包后，发送一个ACK（ACK=1，确认号ack=u+1,序号seq=v）确认报文给客户端，确认号ack为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态，客户端进入FIN-WAIT-2状态。
+ 第三次握手：服务端发送一个关闭连接的FIN包（FIN = 1，ACK = 1，序号seq = w,确认号ack=u+1），确认号与上一次相同，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态。
+ 第四次握手：客户端收到FIN包后，接着发送一个ACK确认报文给服务端（ACK = 1，seq=u+1，ack=w+1），确认号为收到序号+1，进入TIME_WAIT状态，等待计时器设置的时间2MSL后，客户端进入CLOSED状态，服务端收到ACK后进入也CLOSED状态，完成四次握手

### 思考

+ 为什么需要四次握手呢？
  + 因为TCP连接是全双工的工作模式，所以每个方向上需要单独关闭。在TCP关闭连接时，首先关闭的一方（即发送第一个终止数据包的）将执行主动关闭，而另一方（收到这个终止数据包的）再执行被动关闭。

+ 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
  + 虽然四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
  + 所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
